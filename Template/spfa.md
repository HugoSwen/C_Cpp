# spfa 优化策略

## SLF/LLL 优化

SLF(Small Label First)优化： 在使用 queue 作为 spfa 的辅助数据结构时，将队列替换为双端队列，每当插入元素时与队首进行比较，若 dis[qu.front()] > dis[now]，将该元素从队首插入，否则从队尾插入。
LLL(Large Label Last)优化： 同样使用双端队列，维护目前队列中元素到起点的距离的平均值，设该数为 k，若 dis[now] > k，则从队尾插入，否则从队首插入。
两个常用的优化，在随机数据上优化较好，但对精心设计的数据并没有用，在本题中跑的甚至没有朴素版快
被卡到 10/16

## SLF 带容错/mcfx 优化

容错后的 SLF： 定义容错值 val，当满足 dis[now] > dis[q.front()] + val 时从队尾插入，否则从队首插入。
mcfx 优化： 定义区间[l,r]，当入队节点的入队次数属于这个区间的时候，从队首插入，否则从队尾插入。
两个在 SLF 上加强的优化，已经能过数据不刁钻的卡 spfa 的题，但在本题依旧被卡。
14/16

## SLF-swap

Swap-SLF： 若队列改变且 dis[q.front()] > dis[q.back()]，交换队首队尾
一种简单而且较为玄学的优化，有时甚至能卡过极强的 hack，在本题中优于以上所有优化
能达到 15/16

## 随机入队+swap

主流的优化都被卡死了，最好的 swap 能达到 15/16，这时就要考虑玄学优化。
有一种在入队时的做法，每个节点入队时 1/2 概率入队首，1/2 概率入队尾。之后接 swap 优化。终于是过了。
