# Remarks

## memset 用法

> 头文件 cstring 或 memory

```c++
void * memset(void *_Dst,int _Val,size_t _Size);
```

1. 这是 memset 的函数声明
2. 第一个参数为一个指针，即要进行初始化的首地址
3. 第二个参数是初始化值，注意，并不是直接把这个值赋给一个组单元（对 int 来说不是这样）
4. 第三个参数是要初始化首地址后多少个字节

```c++
memset(dp, 0x3f, sizeof dp)
```

1. memset 这个函数的作用是将数字以单个字节逐个拷贝的方式放到指定的内存中去
2. 若 dp 是 int 类型，其为 4 个字节，第二个参数 0x3f 八位为一个字节所以 0x3f \* 4(从高到低复制 4 份) = 0x3f3f3f3f
3. 这也说明了为什么在 memset 中不设置除了-1， 0 以外常见的值
4. 比如 1, 字节表示为 00000001，memset(dp, 1, 4)则表示 0x01010101

## 0x3f3f3f3f 用法

> 为什么要取 0x3f3f3f,为什么不直接定义无穷大 INF = 0x7fffffff,即 32 个 1 来初始化呢？

1. 首先，0x3f3f3f 的体验感很好，0x3f3f3f3f 的十进制是 1061109567，也就是 10^9 级别的（和 0x7fffffff 一个数量级），而一般场合下的数据都是小于 $10^9$ 的，所以它可以作为无穷大使用而不致出现数据大于无穷大的情形。比如 0x3f3f3f3f+0x3f3f3f3f = 2122219134，这非常大但却没有超过 32-bit，int 的表示范围，所以 0x3f3f3f3f 还满足了我们“无穷大加无穷大还是无穷大”的需求。但是 INF 不同，一旦加上某个值，很容易上溢，数值有可能转成负数，有兴趣的小伙伴可以去试一试。

2. 0x3f3f3f3f 还能给我们带来一个意想不到的额外好处：如果我们想要将某个数组清零，我们通常会使用 **memset(a,0,sizeof(a))** 这样的代码来实现（方便而高效），但是当我们想将某个数组全部赋值为无穷大时（例如解决图论问题时邻接矩阵的初始化），就不能使用 memset 函数而得自己写循环了（写这些不重要的代码真的很痛苦），我们知道这是因为 memset 是按字节操作的，它能够对数组清零是因为 0 的每个字节都是 0，现在如果我们将无穷大设为 0x3f3f3f3f，那么奇迹就发生了，0x3f3f3f3f 的每个字节都是 0x3f！所以要把一段内存全部置为无穷大，我们只需要 **memset(a,0x3f,sizeof(a))** 。
